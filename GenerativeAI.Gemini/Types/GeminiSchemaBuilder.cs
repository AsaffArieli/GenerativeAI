using GenerativeAI.Gemini.Attributes;
using GenerativeAI.Gemini.Enums;
using System.Reflection;
using System.Text.Json;

namespace GenerativeAI.Gemini.Types
{
    /// <summary>
    /// Provides utilities for generating structured schema definitions for types used in Gemini prompts.
    /// This static class inspects .NET types and their properties, including custom attributes such as <see cref="GeminiPropertyAttribute"/>,
    /// to produce a dictionary-based schema representation compatible with Gemini's structured prompt requirements.
    /// </summary>
    internal static class GeminiSchemaBuilder
    {
        /// <summary>
        /// Generates a schema dictionary for the specified type, suitable for use in Gemini structured prompts.
        /// </summary>
        /// <param name="type">The .NET type to generate a schema for.</param>
        /// <returns>
        /// A dictionary representing the schema of the type, including type information, properties, required fields, and metadata.
        /// </returns>
        public static Dictionary<string, object> GetSchema(Type type) => BuildSchemaObject(type, initial: true);

        /// <summary>
        /// Recursively builds a schema dictionary for a given type and property.
        /// </summary>
        /// <param name="type">The .NET type to build the schema for.</param>
        /// <param name="propertyInfo">Optional. The property info if building a schema for a property; otherwise, <c>null</c> for the root type.</param>
        /// <param name="initial">Indicates if this is the root schema object (affects which metadata is included).</param>
        /// <returns>A dictionary representing the schema for the type or property.</returns>
        private static Dictionary<string, object> BuildSchemaObject(Type type, PropertyInfo? propertyInfo = null, bool initial = false)
        {
            var fieldType = GetFieldValue(prop => prop?.Type, type, propertyInfo) is { } propType and not GeminiSchemaFieldType.AutoGenerated ? propType : (GeminiSchemaFieldType?)null;
            Dictionary <string, object?> dict = (fieldType ?? GetSchemaType(type)) switch
            {
                var schemaType when schemaType is GeminiSchemaFieldType.Array => new()
                {
                    ["type"] = schemaType,
                    ["items"] = BuildSchemaObject(type.GetElementType() ?? type.GetGenericArguments().First())
                },
                var schemaType when schemaType is GeminiSchemaFieldType.Object => new()
                {
                    ["type"] = schemaType,
                    ["properties"] = BuildProperties(type),
                    ["required"] = BuildRequiredProperties(type) is { Count: > 0 } required ? required : null
                },
                var schemaType when schemaType is GeminiSchemaFieldType.Enum => new()
                {
                    ["type"] = GeminiSchemaFieldType.String,
                    ["enum"] = Enum.GetValues(Nullable.GetUnderlyingType(type) ?? type)
                },
                var schemaType => new() { ["type"] = schemaType }
            };
            dict["title"] = GetFieldValue(prop => prop?.Title, type, propertyInfo);
            dict["description"] = GetFieldValue(prop => prop?.Description, type, propertyInfo);
            if (!initial)
            {
                dict["pattern"] = GetFieldValue(prop => prop?.RegexPattern, type, propertyInfo);
                dict["format"] = GetFieldValue(prop => prop?.Format, type, propertyInfo) switch
                {
                    _ or GeminiPropertyFormatOption.NotSpecified => null
                };
                dict["nullable"] = GetFieldValue(prop => prop?.Nullable, type, propertyInfo) switch
                {
                    GeminiPropertyNullOption.Nullable => true,
                    GeminiPropertyNullOption.NonNullable => false,
                    _ or GeminiPropertyNullOption.NotSpecified => null
                };
            }
            return dict
                .Where(kvp => kvp.Value is string str ? !string.IsNullOrWhiteSpace(str) : kvp.Value is not null)
                .ToDictionary(kvp => kvp.Key, kvp => kvp.Value!);
        }

        /// <summary>
        /// Builds a dictionary of property schemas for all public, writable, non-ignored properties of a type.
        /// </summary>
        /// <param name="type">The .NET type whose properties are to be included.</param>
        /// <returns>
        /// A dictionary mapping property names to their schema definitions.
        /// </returns>
        private static Dictionary<string, Dictionary<string, object>> BuildProperties(Type type)
        {
            return type.GetProperties(BindingFlags.Public | BindingFlags.Instance)
                .Where(property => property.CanWrite && !IsFieldIgnored(property))
                .ToDictionary(
                    property => GetFieldValue(prop => prop?.Name, property.PropertyType, property) ?? property.Name,
                    property => BuildSchemaObject(property.PropertyType, property)
                );
        }

        /// <summary>
        /// Builds a collection of required property names for a type, based on the <see cref="GeminiPropertyAttribute.Required"/> flag.
        /// </summary>
        /// <param name="type">The .NET type to inspect for required properties.</param>
        /// <returns>
        /// A collection of property names that are required in the schema.
        /// </returns>
        private static ICollection<string> BuildRequiredProperties(Type type)
        {
            return [.. type.GetProperties()
                .Where(prop => !IsFieldIgnored(prop))
                .Select(prop => GetFieldValue(prop => prop?.Required, prop.PropertyType, prop) ?? false ? JsonNamingPolicy.CamelCase.ConvertName(GetFieldValue(prop => prop?.Name, prop.PropertyType, prop) ?? prop.Name) : null)
                .OfType<string>()];
        }

        /// <summary>
        /// Determines whether a property should be ignored in the schema, based on the <see cref="GeminiIgnoreAttribute"/>.
        /// </summary>
        /// <param name="propertyInfo">The property to check for the ignore attribute.</param>
        /// <returns><c>true</c> if the property should be ignored; otherwise, <c>false</c>.</returns>
        private static bool IsFieldIgnored(PropertyInfo propertyInfo)
        {
            return propertyInfo.GetCustomAttribute<GeminiIgnoreAttribute>() is { Ignore: true };
        }

        /// <summary>
        /// Retrieves a value from a <see cref="GeminiPropertyAttribute"/> applied to a property or type, using the provided selector function.
        /// </summary>
        /// <typeparam name="TField">The type of the value to retrieve.</typeparam>
        /// <param name="field">A function that selects a value from the attribute.</param>
        /// <param name="type">The type to check for the attribute (optional).</param>
        /// <param name="propertyInfo">The property to check for the attribute (optional).</param>
        /// <returns>The value from the attribute, or <c>null</c> if not present.</returns>
        private static TField? GetFieldValue<TField>(Func<GeminiPropertyAttribute?, TField?> field, Type? type = null, PropertyInfo? propertyInfo = null)
        {
            var propertyAttr = propertyInfo?.GetCustomAttribute<GeminiPropertyAttribute>();
            var typeAttr = type?.GetCustomAttribute<GeminiPropertyAttribute>();
            return field(propertyAttr) ?? field(typeAttr);
        }

        /// <summary>
        /// Determines the <see cref="GeminiSchemaFieldType"/> for a given .NET type.
        /// </summary>
        /// <param name="type">The .NET type to evaluate.</param>
        /// <returns>The corresponding <see cref="GeminiSchemaFieldType"/> value.</returns>
        private static GeminiSchemaFieldType GetSchemaType(Type type)
        {
            return (Nullable.GetUnderlyingType(type) ?? type) switch
            {
                var t when t == typeof(string) => GeminiSchemaFieldType.String,
                var t when t == typeof(int) || t == typeof(long) || t == typeof(short) => GeminiSchemaFieldType.Integer,
                var t when t == typeof(float) || t == typeof(double) || t == typeof(decimal) => GeminiSchemaFieldType.Number,
                var t when t == typeof(bool) => GeminiSchemaFieldType.Boolean,
                var t when t.IsEnum => GeminiSchemaFieldType.Enum,
                var t when t.IsArray || t.IsGenericType && type.GetGenericTypeDefinition() == typeof(IEnumerable<>) => GeminiSchemaFieldType.Array,
                _ => GeminiSchemaFieldType.Object
            };
        }
    }
}
